#!/usr/bin/env python3 """ Teste de Inicializa√ß√£o com Sistema de Log de Depend√™ncias ======================================================== Este arquivo demonstra o uso do sistema de logging de depend√™ncias com prompt engine para detectar e resolver conflitos de vers√µes. Œ®QRH-PROMPT-ENGINE Usage Example """ import sys
 import os import time
 from pathlib import Path # Adicionar caminho do projeto sys.path.insert(0, str(Path(__file__).parent.parent.parent)) # Inicializar o logger ANTES de qualquer
 import from src.core.dependency_logger import DependencyLogger, function_context, log_function_dependencies
 import tempfile # Usar diret√≥rio tempor√°rio para logs temp_dir = tempfile.mkdtemp() log_dir = os.path.join(temp_dir, "dependency_logs") print("Iniciando teste do sistema de log de depend√™ncias Œ®QRH") print("=" * 60) # Inicializar logger logger = DependencyLogger(log_dir=log_dir) print(f"Logger inicializado - Session ID: {logger.session_id}") print(f"Logs salvos em: {log_dir}") # Simular fun√ß√£o de processamento de dados print("\nSimulando fun√ß√£o de processamento de dados...") logger.set_function_context("data_processing") log_function_dependencies("data_processing_main", { "numpy": "1.26.0", "pandas": "2.0.3", "matplotlib": "3.7.0" }) try: import numpy as np
 import pandas as pd print(f"NumPy {np.__version__} importado com sucesso") print(f"Pandas {pd.__version__} importado com sucesso") except ImportError as e: print(f"Erro ao importar: {e}") # Simular fun√ß√£o de machine learning print("\nSimulando fun√ß√£o de machine learning...") with function_context("ml_training"): log_function_dependencies("neural_network_training", { "torch": "2.1.2", "numpy": "1.24.0", # Vers√£o DIFERENTE - vai gerar conflito! "matplotlib": "3.7.5" # Vers√£o ligeiramente diferente }) try: import torch print(f"PyTorch {torch.__version__}
 importado com sucesso") # Usar numpy novamente (mas logger j√° detectou o conflito) import numpy as np print(f"NumPy {np.__version__} re-
importado (poss√≠vel conflito)") except ImportError as e: print(f"Erro ao importar: {e}") # Simular fun√ß√£o de visualiza√ß√£o print("\nSimulando fun√ß√£o de visualiza√ß√£o...") with function_context("visualization"): log_function_dependencies("plot_generation", { "matplotlib": "3.7.5", "seaborn": "0.13.0", "plotly": "5.17.0" }) try: import matplotlib.pyplot as plt print(f"Matplotlib {plt.matplotlib.__version__}
 importado") except ImportError as e: print(f"Erro ao importar matplotlib: {e}") # Simular imports problem√°ticos print("\nSimulando imports com problemas conhecidos...") with function_context("problematic_imports"): # Tentar importar algo que sabemos que vai dar erro try: import nonexistent_library except ImportError: print("Import esperado de biblioteca inexistente (normal)") # Import lento simulado print("Simulando
 import lento...") time.sleep(0.1) # Simular demora print("\n" + "=" * 60) print("GERANDO RELAT√ìRIO DE COMPATIBILIDADE") print("=" * 60) # Gerar relat√≥rio completo compatibility_report = logger.generate_compatibility_report() print(compatibility_report) print("\n" + "=" * 60) print("SALVANDO LOGS E AN√ÅLISES") print("=" * 60) # Salvar todos os dados logger.save_log() # An√°lise de dados hist√≥ricos (se existirem) try: historical_analysis = logger.analyze_historical_conflicts() print("\nAN√ÅLISE HIST√ìRICA:") print(f"Total de sess√µes anteriores: {historical_analysis['total_sessions']}") print(f"Total de conflitos hist√≥ricos: {historical_analysis['total_conflicts']}") if historical_analysis['recurring_conflicts']: print("\nüîÑ Conflitos recorrentes:") for lib, count in historical_analysis['recurring_conflicts'].items(): print(f" - {lib}: {count} ocorr√™ncias") if historical_analysis['most_problematic']: lib, count = historical_analysis['most_problematic'] print(f"\nüö® Biblioteca mais problem√°tica: {lib} ({count} conflitos)") except Exception as e: print(f"‚ÑπÔ∏è An√°lise hist√≥rica n√£o dispon√≠vel: {e}") # Dados para cruzamento cross_ref_data = logger.get_cross_reference_data() print(f"\nüîó Dados de refer√™ncia cruzada gerados para sess√£o {cross_ref_data['session_id']}") print(f"Dependencies tracked: {len(cross_ref_data['dependencies'])}") print(f"Conflicts logged: {len(cross_ref_data['conflicts'])}") print("\n" + "=" * 60) print("TESTE DE INICIALIZA√á√ÉO CONCLU√çDO") print("=" * 60) # PROMPT ESPEC√çFICO PARA AN√ÅLISE ANALYSIS_PROMPT = """ Œ®QRH-PROMPT-ENGINE: { "context": "An√°lise completa do sistema de log de depend√™ncias", "analysis": "Sistema detectou conflitos entre vers√µes de numpy em fun√ß√µes diferentes", "solution": "Implementar estrat√©gia de unifica√ß√£o de vers√µes", "implementation": [ "Detectar automaticamente conflitos de vers√£o", "Sugerir vers√µes compat√≠veis via IA", "Manter hist√≥rico de conflitos", "Gerar relat√≥rios de compatibilidade" ], "validation": "Sistema funcionando corretamente com detec√ß√£o de conflitos" } Este sistema permite: 1. **Detec√ß√£o Autom√°tica**: Monitora todas as importa√ß√µes em tempo real 2. **Conflitos de Vers√£o**: Identifica quando diferentes fun√ß√µes precisam de vers√µes diferentes 3. **An√°lise Inteligente**: Usa prompt engine para sugerir resolu√ß√µes 4. **Relat√≥rios Detalhados**: Gera logs e relat√≥rios de compatibilidade 5. üîÑ **Hist√≥rico**: Mant√©m registro para an√°lise de padr√µes 6. üîó **Cruzamento de Dados**: Permite comparar entre sess√µes diferentes Casos de Uso: - Fun√ß√£o A precisa numpy 1.26.0 para novos recursos - Fun√ß√£o B precisa numpy 1.24.0 por compatibilidade legada - Sistema detecta conflito e sugere vers√£o compat√≠vel - Mant√©m log para futuras refer√™ncias O prompt engine analisa os conflitos e sugere resolu√ß√µes inteligentes baseadas no contexto espec√≠fico de cada biblioteca e fun√ß√£o. """ print("\nPROMPT DE AN√ÅLISE GERADO:") print(ANALYSIS_PROMPT) print(f"\nSession ID para refer√™ncia: {logger.session_id}") print("Logs salvos em: logs/dependencies/")