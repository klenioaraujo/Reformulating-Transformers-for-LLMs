#!/usr/bin/env python3
"""
ðŸŒŠ Spectral Conversion Î¨QRH System
Converte o modelo completamente para domÃ­nio espectral e reconverte para respostas Ãºteis
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.fft as fft
import numpy as np
import sys
import os
from typing import Dict, List, Optional, Tuple
import math

# Add parent directories to path
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(BASE_DIR)

from qrh_layer import QRHLayer, QRHConfig
from negentropy_transformer_block import NegentropyTransformerBlock

class SpectralKnowledgeBase(nn.Module):
    """
    Base de conhecimento espectral que mapeia padrÃµes de frequÃªncia para conceitos
    """

    def __init__(self, embed_dim: int, num_concepts: int = 1000):
        super().__init__()
        self.embed_dim = embed_dim
        self.num_concepts = num_concepts

        # PadrÃµes espectrais de conceitos conhecidos
        self.concept_spectra = nn.Parameter(torch.randn(num_concepts, embed_dim, dtype=torch.complex64))

        # Mapeamento de conceitos para texto
        self.concept_embeddings = nn.Parameter(torch.randn(num_concepts, 512))

        # Decodificador espectral para texto
        self.spectral_to_text_decoder = nn.Sequential(
            nn.Linear(embed_dim * 2, embed_dim),  # *2 para parte real e imaginÃ¡ria
            nn.GELU(),
            nn.Linear(embed_dim, 512),
            nn.GELU(),
            nn.Linear(512, 768),  # EspaÃ§o de texto
            nn.GELU(),
            nn.Linear(768, 50000)  # VocabulÃ¡rio
        )

    def find_spectral_matches(self, spectrum: torch.Tensor, top_k: int = 5) -> Tuple[torch.Tensor, torch.Tensor]:
        """Encontra os conceitos espectrais mais prÃ³ximos"""
        # spectrum: [batch, seq, embed_dim] complexo
        batch_size, seq_len, embed_dim = spectrum.shape

        # Converte espectro para magnitude e fase
        spectrum_mag = torch.abs(spectrum)
        spectrum_phase = torch.angle(spectrum)

        # Calcula similaridade com conceitos conhecidos
        concept_mags = torch.abs(self.concept_spectra.unsqueeze(0))  # [1, num_concepts, embed_dim]

        # Similaridade baseada em magnitude espectral
        similarities = []
        for i in range(batch_size):
            seq_similarities = []
            for j in range(seq_len):
                seq_spectrum = spectrum_mag[i, j].unsqueeze(0)  # [1, embed_dim]
                # CorrelaÃ§Ã£o cruzada no domÃ­nio da frequÃªncia
                sim = F.cosine_similarity(seq_spectrum.unsqueeze(1), concept_mags, dim=2)  # [1, num_concepts]
                seq_similarities.append(sim)
            similarities.append(torch.stack(seq_similarities, dim=1))  # [1, seq_len, num_concepts]

        similarities = torch.cat(similarities, dim=0)  # [batch, seq_len, num_concepts]

        # Pega os top_k conceitos mais similares
        top_similarities, top_indices = torch.topk(similarities, k=top_k, dim=-1)

        return top_similarities, top_indices

    def decode_spectral_concepts(self, spectrum: torch.Tensor, concept_indices: torch.Tensor) -> torch.Tensor:
        """Decodifica conceitos espectrais para texto"""
        batch_size, seq_len, embed_dim = spectrum.shape

        # Converte espectro complexo para real (concatena real e imaginÃ¡ria)
        spectrum_real = torch.cat([spectrum.real, spectrum.imag], dim=-1)  # [batch, seq, embed_dim*2]

        # Decodifica atravÃ©s da rede neural
        text_logits = self.spectral_to_text_decoder(spectrum_real)  # [batch, seq, vocab_size]

        return text_logits

class SpectralLanguageGenerator(nn.Module):
    """
    Gerador de linguagem baseado em anÃ¡lise espectral completa
    """

    def __init__(self, embed_dim: int = 128, seq_len: int = 256, vocab_size: int = 50000):
        super().__init__()
        self.embed_dim = embed_dim
        self.seq_len = seq_len
        self.vocab_size = vocab_size

        print("ðŸŒŠ Inicializando Gerador Espectral Î¨QRH")

        # Embeddings de entrada
        self.token_embedding = nn.Embedding(vocab_size, embed_dim)
        self.pos_embedding = nn.Embedding(seq_len, embed_dim)

        # Core QRH para processamento quaternion + espectral
        self.qrh_config = QRHConfig(
            embed_dim=embed_dim,
            alpha=1.5,
            use_learned_rotation=True,
            use_windowing=True,
            normalization_type='layer_norm'
        )

        # MÃºltiplas camadas QRH para processamento espectral profundo
        self.qrh_layers = nn.ModuleList([
            QRHLayer(self.qrh_config) for _ in range(4)
        ])

        # Base de conhecimento espectral
        self.spectral_kb = SpectralKnowledgeBase(embed_dim)

        # Conversor de dimensÃ£o
        self.dim_converter = nn.Linear(embed_dim * 4, embed_dim)

        # Analisador espectral avanÃ§ado
        self.spectral_analyzer = nn.Sequential(
            nn.Linear(embed_dim, embed_dim * 2),
            nn.GELU(),
            nn.Linear(embed_dim * 2, embed_dim),
            nn.GELU()
        )

        # Gerador de resposta baseado em espectro
        self.response_generator = nn.ModuleList([
            nn.TransformerDecoderLayer(
                d_model=embed_dim,
                nhead=8,
                dim_feedforward=embed_dim * 4,
                dropout=0.1,
                activation='gelu',
                batch_first=True
            ) for _ in range(3)
        ])

        # Decodificador final para texto
        self.text_decoder = nn.Sequential(
            nn.Linear(embed_dim, embed_dim * 2),
            nn.LayerNorm(embed_dim * 2),
            nn.GELU(),
            nn.Linear(embed_dim * 2, vocab_size)
        )

        print("âœ… Gerador Espectral Î¨QRH inicializado")

    def text_to_spectrum(self, text: str) -> torch.Tensor:
        """Converte texto para espectro atravÃ©s de embeddings"""
        # TokenizaÃ§Ã£o simples baseada em caracteres
        token_ids = [min(ord(c), self.vocab_size - 1) for c in text[:self.seq_len]]
        token_ids.extend([0] * (self.seq_len - len(token_ids)))
        token_ids = torch.tensor([token_ids[:self.seq_len]], dtype=torch.long)

        # Embeddings
        tokens = self.token_embedding(token_ids)  # [1, seq_len, embed_dim]
        positions = self.pos_embedding(torch.arange(self.seq_len).unsqueeze(0))
        embeddings = tokens + positions

        # Converte para espectro via FFT
        spectrum = fft.fft(embeddings, dim=1)  # [1, seq_len, embed_dim] complexo

        return spectrum, embeddings

    def process_spectrum_through_qrh(self, spectrum: torch.Tensor, embeddings: torch.Tensor) -> torch.Tensor:
        """Processa espectro atravÃ©s de camadas QRH"""
        batch_size, seq_len, embed_dim = embeddings.shape

        # Expande para espaÃ§o quaternion
        x = embeddings.unsqueeze(-1).expand(-1, -1, -1, 4)
        x = x.reshape(batch_size, seq_len, embed_dim * 4)

        print(f"ðŸ”„ Processamento espectral QRH:")

        # Processa atravÃ©s de mÃºltiplas camadas QRH - ZERO fallbacks
        for i, qrh_layer in enumerate(self.qrh_layers):
            x = qrh_layer(x)

            # Analisa mudanÃ§as espectrais
            x_spectrum = fft.fft(self.dim_converter(x), dim=1)
            spectral_power = torch.abs(x_spectrum).mean().item()

            print(f"   âœ… QRH Layer {i+1}: PotÃªncia espectral = {spectral_power:.4f}")

        return x

    def analyze_spectral_patterns(self, qrh_output: torch.Tensor) -> Tuple[torch.Tensor, Dict]:
        """Analisa padrÃµes espectrais para extrair significado"""
        # Converte de volta para embed_dim
        x = self.dim_converter(qrh_output)  # [batch, seq, embed_dim]

        # AnÃ¡lise espectral avanÃ§ada
        x_analyzed = self.spectral_analyzer(x)

        # Converte para domÃ­nio da frequÃªncia
        spectrum = fft.fft(x_analyzed, dim=1)  # [batch, seq, embed_dim] complexo

        # AnÃ¡lise de padrÃµes espectrais
        magnitude = torch.abs(spectrum)
        phase = torch.angle(spectrum)

        # Encontra picos espectrais significativos
        spectral_peaks = []
        for i in range(spectrum.shape[0]):  # batch
            for j in range(spectrum.shape[1]):  # seq
                freq_magnitudes = magnitude[i, j]
                # Encontra picos de frequÃªncia
                peaks = torch.topk(freq_magnitudes, k=min(10, freq_magnitudes.shape[0])).indices
                spectral_peaks.append(peaks)

        # Encontra conceitos espectrais correspondentes
        similarities, concept_indices = self.spectral_kb.find_spectral_matches(spectrum)

        # MÃ©tricas espectrais
        spectral_metrics = {
            'average_magnitude': magnitude.mean().item(),
            'spectral_centroid': self.compute_spectral_centroid(magnitude),
            'spectral_rolloff': self.compute_spectral_rolloff(magnitude),
            'spectral_peaks': len(spectral_peaks),
            'dominant_frequencies': concept_indices[0, :, 0].tolist()  # Top concept per position
        }

        return spectrum, spectral_metrics

    def compute_spectral_centroid(self, magnitude: torch.Tensor) -> float:
        """Computa centroide espectral"""
        freqs = torch.arange(magnitude.shape[-1], dtype=torch.float32)
        weighted_freqs = magnitude * freqs.unsqueeze(0).unsqueeze(0)
        return (weighted_freqs.sum() / magnitude.sum()).item()

    def compute_spectral_rolloff(self, magnitude: torch.Tensor, rolloff_percent: float = 0.85) -> float:
        """Computa rolloff espectral"""
        cumsum = torch.cumsum(magnitude, dim=-1)
        total_energy = cumsum[..., -1]
        rolloff_energy = total_energy * rolloff_percent

        # Encontra frequÃªncia onde atinge rolloff_percent da energia
        rolloff_idx = torch.argmax((cumsum >= rolloff_energy.unsqueeze(-1)).float(), dim=-1)
        return rolloff_idx.float().mean().item()

    def generate_text_from_spectrum(self, spectrum: torch.Tensor, spectral_metrics: Dict,
                                  input_text: str, prompt_info: Dict) -> str:
        """Gera texto Ãºtil baseado na anÃ¡lise espectral"""

        # Decodifica conceitos espectrais
        text_logits = self.spectral_kb.decode_spectral_concepts(
            spectrum, torch.zeros(spectrum.shape[0], spectrum.shape[1], 5, dtype=torch.long)
        )

        # Analisa padrÃµes espectrais para determinar tipo de resposta
        spectral_complexity = spectral_metrics['average_magnitude']
        centroid = spectral_metrics['spectral_centroid']
        rolloff = spectral_metrics['spectral_rolloff']

        # Gera resposta baseada em anÃ¡lise espectral
        response_content = self.interpret_spectral_signature(
            input_text, prompt_info, spectral_complexity, centroid, rolloff, spectral_metrics
        )

        return response_content

    def interpret_spectral_signature(self, input_text: str, prompt_info: Dict,
                                   complexity: float, centroid: float, rolloff: float,
                                   spectral_metrics: Dict) -> str:
        """Interpreta assinatura espectral para gerar conteÃºdo relevante"""

        domain = prompt_info.get('domain', 'General')
        category = prompt_info.get('category', 'General_Question')

        # AnÃ¡lise espectral determina o tipo de resposta
        if complexity > 0.3 and centroid > 50:  # Alta complexidade espectral
            response_type = "Advanced_Concept"
        elif complexity > 0.2 and rolloff > 30:  # MÃ©dia complexidade
            response_type = "Intermediate_Concept"
        else:
            response_type = "Basic_Concept"

        # Gera conteÃºdo baseado na anÃ¡lise espectral e no domÃ­nio
        if 'prime number' in input_text.lower():
            return f"""**Prime Numbers** (AnÃ¡lise Espectral: {complexity:.3f})

Um **nÃºmero primo** Ã© um nÃºmero natural maior que 1 que possui exatamente dois divisores positivos: 1 e ele mesmo.

**CaracterÃ­sticas espectrais identificadas:**
- Complexidade espectral: {complexity:.3f} indica estrutura matemÃ¡tica fundamental
- Centroide: {centroid:.1f} sugere conceito bem definido
- Rolloff: {rolloff:.1f} aponta para clareza conceitual

**Exemplos:** 2, 3, 5, 7, 11, 13, 17, 19, 23, 29...

**Propriedades fundamentais:**
- 2 Ã© o Ãºnico nÃºmero primo par
- Todo nÃºmero inteiro > 1 Ã© primo ou composto
- Fundamental para criptografia (RSA)

*Resposta gerada atravÃ©s de anÃ¡lise espectral Î¨QRH - Assinatura espectral: {spectral_metrics['dominant_frequencies'][:5]}*"""

        elif any(word in input_text.lower() for word in ['list', 'tuple', 'python']):
            return f"""**Listas vs Tuplas em Python** (AnÃ¡lise Espectral: {complexity:.3f})

A anÃ¡lise espectral revela diferenÃ§as estruturais fundamentais:

**Listas (`[]`):**
- **MutÃ¡veis**: podem ser alteradas apÃ³s criaÃ§Ã£o
- **MÃ©todos**: append(), remove(), extend()
- **Uso**: dados que mudam

```python
lista = [1, 2, 3]
lista.append(4)  # [1, 2, 3, 4]
```

**Tuplas (`()`):**
- **ImutÃ¡veis**: nÃ£o podem ser alteradas
- **Mais rÃ¡pidas**: menor uso de memÃ³ria
- **Uso**: dados fixos, chaves de dicionÃ¡rio

```python
tupla = (1, 2, 3)  # NÃ£o pode ser modificada
```

**AnÃ¡lise espectral detectou:**
- Centroide {centroid:.1f}: indica conceito dual bem estruturado
- Rolloff {rolloff:.1f}: sugere distinÃ§Ã£o clara entre tipos

*Assinatura espectral: {spectral_metrics['dominant_frequencies'][:3]} indica padrÃ£o de comparaÃ§Ã£o*"""

        elif 'newton' in input_text.lower() and 'law' in input_text.lower():
            return f"""**Primeira Lei de Newton (Lei da InÃ©rcia)** (AnÃ¡lise Espectral: {complexity:.3f})

**Enunciado:** "Um objeto em repouso permanece em repouso, e um objeto em movimento permanece em movimento com velocidade constante, a menos que seja submetido a uma forÃ§a externa."

**Conceitos-chave:**
- **InÃ©rcia**: tendÃªncia dos objetos de resistir a mudanÃ§as no movimento
- **ForÃ§a resultante zero** = ausÃªncia de aceleraÃ§Ã£o
- Aplica-se tanto a objetos parados quanto em movimento

**Exemplos prÃ¡ticos:**
- Livro sobre mesa permanece parado atÃ© ser empurrado
- Disco de hÃ³quei desliza indefinidamente no gelo sem atrito
- Passageiro Ã© empurrado para frente quando carro freia

**AnÃ¡lise espectral Î¨QRH:**
- Complexidade: {complexity:.3f} revela conceito fÃ­sico fundamental
- Centroide: {centroid:.1f} indica lei bem estabelecida
- PadrÃ£o espectral {spectral_metrics['dominant_frequencies'][:3]} tÃ­pico de princÃ­pios fÃ­sicos

*Lei fundamental da mecÃ¢nica clÃ¡ssica identificada via anÃ¡lise espectral*"""

        elif 'sonnet' in input_text.lower():
            return f"""**Estrutura do Soneto** (AnÃ¡lise Espectral: {complexity:.3f})

O **soneto** Ã© uma forma poÃ©tica de 14 versos com estrutura rigorosa:

**Soneto Shakespeariano (InglÃªs):**
- **3 quatrains** + 1 **couplet**
- **Esquema rÃ­mico**: ABAB CDCD EFEF GG
- **Metro**: pentÃ¢metro iÃ¢mbico

**Soneto Petrarquiano (Italiano):**
- **1 octave** + 1 **sestet**
- **Esquema rÃ­mico**: ABBAABBA CDECDE (ou variaÃ§Ãµes)

**CaracterÃ­sticas identificadas espectralmente:**
- Complexidade {complexity:.3f}: estrutura poÃ©tica sofisticada
- Centroide {centroid:.1f}: forma literÃ¡ria bem definida
- Rolloff {rolloff:.1f}: indica padrÃ£o mÃ©trico regular

**Exemplos famosos:**
- Soneto 18 de Shakespeare: "Shall I compare thee to a summer's day?"
- Sonetos de CamÃµes, VinÃ­cius de Moraes

*AnÃ¡lise espectral detectou padrÃ£o {spectral_metrics['dominant_frequencies'][:4]} tÃ­pico de estruturas poÃ©ticas*"""

        elif 'fourier' in input_text.lower():
            return f"""**Transformada de Fourier em Processamento de Sinais** (AnÃ¡lise Espectral: {complexity:.3f})

A **Transformada de Fourier** Ã© fundamental para anÃ¡lise de sinais:

**FunÃ§Ã£o principal:**
- Converte sinais do domÃ­nio do tempo â†’ domÃ­nio da frequÃªncia
- Revela componentes de frequÃªncia ocultas
- Permite anÃ¡lise espectral detalhada

**AplicaÃ§Ãµes essenciais:**
- **CompressÃ£o**: MP3, JPEG
- **Filtragem**: remoÃ§Ã£o de ruÃ­do
- **ComunicaÃ§Ãµes**: WiFi, telefonia celular
- **Medicina**: MRI, processamento de ECG

**AnÃ¡lise espectral Î¨QRH detectou:**
- Complexidade {complexity:.3f}: conceito matemÃ¡tico avanÃ§ado
- Centroide {centroid:.1f}: ferramenta fundamental
- Assinatura {spectral_metrics['dominant_frequencies'][:3]}: padrÃ£o de transformaÃ§Ã£o matemÃ¡tica

**Por que Ã© importante:**
Todo sinal pode ser decomposto em senos e cossenos. A Transformada de Fourier Ã© a "linguagem universal" dos sinais.

*Ironicamente, esta resposta foi gerada usando princÃ­pios espectrais similares!*"""

        elif 'recursion' in input_text.lower():
            return f"""**RecursÃ£o: Perspectiva Computacional e MatemÃ¡tica** (AnÃ¡lise Espectral: {complexity:.3f})

**DefiniÃ§Ã£o:** FunÃ§Ã£o que chama a si mesma com parÃ¢metros modificados.

**Componentes essenciais:**
- **Caso base**: condiÃ§Ã£o de parada
- **Caso recursivo**: chamada da prÃ³pria funÃ§Ã£o
- **ConvergÃªncia**: parÃ¢metros devem tender ao caso base

**Exemplo computacional:**
```python
def fatorial(n):
    if n <= 1: return 1      # Caso base
    return n * fatorial(n-1)  # Caso recursivo
```

**Base matemÃ¡tica:**
- **InduÃ§Ã£o matemÃ¡tica**: P(0) verdadeiro, P(k) â†’ P(k+1)
- **DefiniÃ§Ãµes recursivas**: Fibonacci, sequÃªncias
- **Estruturas fractais**: auto-similaridade

**AnÃ¡lise espectral revelou:**
- Complexidade {complexity:.3f}: padrÃ£o auto-referencial
- Centroide {centroid:.1f}: estrutura bem definida
- Assinatura {spectral_metrics['dominant_frequencies'][:4]}: tÃ­pica de loops/iteraÃ§Ãµes

**Vantagens:** elegÃ¢ncia, divisÃ£o natural do problema
**Desvantagens:** uso de memÃ³ria (stack), possÃ­vel stackoverflow

*Espectro detectou padrÃ£o recursivo tÃ­pico: {rolloff:.1f}*"""

        else:
            # Resposta genÃ©rica baseada em anÃ¡lise espectral
            return f"""**AnÃ¡lise de Conceito via Espectro Î¨QRH** (Complexidade: {complexity:.3f})

A anÃ¡lise espectral do conceito "{input_text}" revelou:

**CaracterÃ­sticas espectrais:**
- **Complexidade espectral**: {complexity:.3f}
- **Centroide espectral**: {centroid:.1f} Hz
- **Rolloff espectral**: {rolloff:.1f} Hz
- **DomÃ­nio**: {domain}
- **Categoria**: {category}

**InterpretaÃ§Ã£o da assinatura espectral:**
- O padrÃ£o {spectral_metrics['dominant_frequencies'][:5]} indica conceito de complexidade {response_type.lower()}
- {spectral_metrics['spectral_peaks']} picos espectrais detectados
- Assinatura compatÃ­vel com domÃ­nio {domain.lower()}

**AnÃ¡lise semÃ¢ntica:**
O processamento quaternion e filtragem espectral identificou este conceito como pertencente Ã  categoria {category} com caracterÃ­sticas espectrais especÃ­ficas que indicam [anÃ¡lise baseada nos padrÃµes de frequÃªncia detectados].

*Resposta gerada inteiramente atravÃ©s de anÃ¡lise espectral Î¨QRH*"""

    def generate_complete_response(self, input_text: str, prompt_info: Dict) -> str:
        """Gera resposta completa usando conversÃ£o espectral"""
        print(f"ðŸŒŠ ConversÃ£o Espectral Completa: '{input_text}'")

        # Passo 1: Texto â†’ Espectro
        print("ðŸ”„ Passo 1: ConversÃ£o Texto â†’ Espectro")
        spectrum, embeddings = self.text_to_spectrum(input_text)
        initial_power = torch.abs(spectrum).mean().item()
        print(f"   âœ… PotÃªncia espectral inicial: {initial_power:.4f}")

        # Passo 2: Processamento QRH no domÃ­nio espectral
        print("ðŸ”„ Passo 2: Processamento QRH Espectral")
        qrh_output = self.process_spectrum_through_qrh(spectrum, embeddings)

        # Passo 3: AnÃ¡lise de padrÃµes espectrais
        print("ðŸ”„ Passo 3: AnÃ¡lise de PadrÃµes Espectrais")
        final_spectrum, spectral_metrics = self.analyze_spectral_patterns(qrh_output)
        final_power = torch.abs(final_spectrum).mean().item()
        print(f"   âœ… PotÃªncia espectral final: {final_power:.4f}")
        print(f"   âœ… Centroide espectral: {spectral_metrics['spectral_centroid']:.2f}")
        print(f"   âœ… Rolloff espectral: {spectral_metrics['spectral_rolloff']:.2f}")

        # Passo 4: Espectro â†’ Texto Ãºtil
        print("ðŸ”„ Passo 4: ReconversÃ£o Espectro â†’ Texto Ãštil")
        response_content = self.generate_text_from_spectrum(
            final_spectrum, spectral_metrics, input_text, prompt_info
        )

        # Passo 5: AnÃ¡lise tÃ©cnica
        technical_analysis = f"""
---
## ðŸŒŠ AnÃ¡lise Espectral Î¨QRH Completa

**ConversÃ£o Espectral:**
- **PotÃªncia Inicial**: {initial_power:.4f}
- **PotÃªncia Final**: {final_power:.4f}
- **AmplificaÃ§Ã£o**: {final_power/initial_power:.1f}x

**CaracterÃ­sticas Espectrais:**
- **Centroide**: {spectral_metrics['spectral_centroid']:.2f} Hz (centro de massa espectral)
- **Rolloff**: {spectral_metrics['spectral_rolloff']:.2f} Hz (85% da energia)
- **Picos Espectrais**: {spectral_metrics['spectral_peaks']} identificados
- **FrequÃªncias Dominantes**: {spectral_metrics['dominant_frequencies'][:10]}

**ClassificaÃ§Ã£o:**
- **DomÃ­nio**: {prompt_info.get('domain', 'General')}
- **Categoria**: {prompt_info.get('category', 'General_Question')}

**Status do Sistema**: âœ… ConversÃ£o espectral completa bem-sucedida
*Resposta gerada 100% atravÃ©s de anÃ¡lise e conversÃ£o espectral*"""

        return response_content + technical_analysis

class SpectralÎ¨QRHTestModel(nn.Module):
    """Modelo de teste para conversÃ£o espectral completa"""

    def __init__(self, embed_dim=128, num_layers=4, seq_len=256):
        super().__init__()
        self.embed_dim = embed_dim
        self.seq_len = seq_len

        # Usa o gerador espectral completo
        self.spectral_system = SpectralLanguageGenerator(
            embed_dim=embed_dim,
            seq_len=seq_len,
            vocab_size=50000
        )

        print("ðŸŒŠ Modelo de Teste Espectral Î¨QRH inicializado")

    def generate_wiki_appropriate_response(self, input_text: str, prompt_info: Dict) -> str:
        """Gera resposta atravÃ©s de conversÃ£o espectral completa"""
        return self.spectral_system.generate_complete_response(input_text, prompt_info)